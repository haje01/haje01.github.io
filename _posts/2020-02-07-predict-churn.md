---
layout: post
title: predict-churn
description:
date: 2020-02-07
tags: [idea]
---

# 이탈 예측을 어떻게 할 것인가?

예전에 게임 유저 이탈 예측을 시도해 보았는데, 성과가 썩 좋지는 않았다. 이번에 아래의 사항을 고려하여 다시 시도해보려 한다.

## 개선할 것

### 유저 플레이 빈도 고려

저번에는 매일 플레이하는 유저나, 주말에만 플레이 하는 유저나 같은 모델을 사용해서 했는데, 이 부분이 성능에 영향을 끼쳤을 것 같다.

### 고도화된 피처 엔지니어링 및 HPO

저번에는 수작업된 피처들과 초모수로 훈련하였다. 최근에 Featuretools 등의 자동 피처 합성기와 Dask 나 Ray 클러스터를 사용한 초모수 최적화(Hyper-parameter Optimization) 테크닉을 알게되어 사용해보려한다. 얼마 안되는 피처에서 대충 설정한 초모수 보다는 좋은 결과가 기대된다.


## 플레이 빈도별 유저 군집화

* 유저를 한 주당 플레이한 날의 평균에 따라 U1 부터 U7 군집으로 나눈다.
* 군집 분류:
  * G1 - 일 주일에 한 번 플레이하는 유저군
  * G2 - 일 주일에 두 번 플레이하는 유저군
  * ...
  * G6 - 일 주일에 여섯 번 플레이하는 유저군
  * G7 - 일 주일 내내 플레이하는 유저군

* 일주일에 평균 한 번 미만으로 플레이하는 유저는 학습 및 예측 대상으로 하지 않는다.
* 시간이 흐름에 따라 유저가 속한 군집이 바뀔 수 있기에, 가급적 최신 데이터로 분류한다.

### 유저 군집의 활용

* 유저 군집별로 학습 / 예측 데이터를 준비한다.
* 유저 군집별로 예측 모델을 학습한다.

## 용어와 변수

> **주의 :** 아래 용어와 변수는 따로 명시되지 않으면 각 *유저* 에 관한 것이다. *군집* 은 유저가 속한 군집을 말한다.

* *예측일 (target_day)* : 예측하는 날자
* *참석일 (play)* : 플레이한 날
* *결석일 (absent)* : 플레이하지 않은 날
* *마지막 참석일 (last_play, l)* : 예측일 전 마지막 참석일
* *기간 참석일 (plays, p)* : t 일 동안 참석한 수
  * 10 일 동안 4번 참석한 경우 $p_{10} = 4$
* *주당 참석일 수 (week_plays, w)* : 기간 참석일 수를 주에 대한 값으로 계산한 것. t 일 동안 n 번 참석한 경우:

$$w = \frac {p} {t} \times 7$$

* 주당 참석일로 유저가 속한 군집을 결정한다.

* 군집 (*group, G*) : 유저가 속한 군집.
* *군집 결정 기간 (group_decide_days, G_d)* : 유저 군집 결정에 필요한 일 수
* *군집 주당 참석일 (group_week_plays, G_w)* : 군집의 주당 참석일. 배정된 유저의 주당 참석일과 같다.
* 군집 결정 기간 참석일 수 (*group_decide_plays, G_p*) 는 군집 결정 기간동안 참석일 수
* 군집 참석 주기 (*group_play_freq, G_f*) 는 군집 결정 기간 (G_d) 을 군집 결정 기간 참석일 수 (G_p) 로 나눈 값

$$G_f = \frac {G_d} {G_p} $$

* *참석 예정일 (due_play_day, e)* 은 유저의 마지막 첨석일 이후 예상되는 다음 참석일. 마지막 참석일 (l) 과 군집 참석 주기 (G_f) 로 계산.

$$e = l + G_f$$

* 결석률 (*absent_rate, a*) 은 다음 참석 예정일 (e) 이후, 예측일 (t) 까지 결석일 수를 군집 참석 주기 주기에 대한 비율로 나타낸 것 (0 이상)
  * 참석 주기가 3일인 군집에 속한 유저가 6일 동안 결석했다면, 결석율은 1

$$a = max \left( \frac {t - e} {f} - 1, 0 \right) $$


## 데이터 준비

데이터는 유저별 일단위 피처 데이터로 구성된다.

### 학습 데이터

학습 데이터 (learn_data, L)* 에서 각 군집별 학습 데이터가 만들어 진다.

* *학습 데이터 일 수 (learn_data_days, L_days)* : 전체 학습 데이터의 일 수
  * 데이터는 많을 수록 좋으나, 개념 표류 (*Concept Drifting*) 를 피하기 위해 적절한 L_days 를 선택할 필요가 있다. 이에 L_days 를 초모수로 둔다.
* *학습 데이터 시작일 (learn_data_begin, L_begin)* : 학습 데이터의 시작 날자
* *학습 데이터 종료일 (learn_data_end, L_end)* : 학습 데이터의 마지막 날자
  * 학습 데이터 종료일 (L_end) 은, 이어 설명할 예측 데이터 시작일 (P_begin) 보다 작아야 함
* 학습 데이터의 시작일은 학습 데이터 종료일 (L_end) 과 학습 데이터 일 수 (L_days) 로 결정

$$L_{begin} = L_{end} - L_{days}$$


#### 군집 학습 데이터

학습 데이터에서 *군집 학습 데이터 (group_learn_data, R)* 를 다음과 같이 준비

* 군집별로 학습 데이터 크기는 달라진다.
  * G1 처럼 참석 주기가 짧은 군집은, G7 보다 학습 데이터 일 수가 작다.
  * 그러나, 빈도가 낮기에 유저당 데이터의 총량은 비슷할 것
* 데이터는 많을 수록 좋으나, 개념 표류 (*Concept Drifting*) 를 피하기 위해 군집별로 적절한 L_days 를 선택할 필요가 있다. 이를 위해 군집 참석 주기의 k (초모수) 배를 이용
  * 예를 들어 2일 참석 주기의 군집에 대해 k = 10 을 적용하면 L_days = 20 이 된다.

$$L_{days} = G_f \times k $$


$$ L_{end} < P_{begin} $$

* 데이터 양을 늘리기 위해 슬라이딩 윈도우 (*learn_window*) 로 데이터를 수집
  * *학습 윈도우 크기 (learn_window_width, L_width)* 는 이 슬라이딩 윈도우의 크기
  * *학습 윈도우 스텝 (learn_window_step, L_step)* 은 이 슬라이딩 윈도우의 진행 스텝
    * 중복을 허용하되, 적정 수준을 유지하기 위해 L_step 은 L_width 의 c (초모수) 비율 수준으로

$$L_{step} = L_{width} \times c, (0 \lt c \leq 1) $$

  * 학습 윈도우 크기 (*L_width*)는 이탈 여부 판정이 가능하도록 설정

$$ L_{width} \geq P_{size} $$

* 각 윈도우에서 참석일 수가 예측 데이터 크기 (*p_size*) 보다 작은 유저는 제외
* 각 윈도우 별 이탈 (*churn*) / 활성 (*active*) 유저 라벨링
  * 이탈 유저는 윈도우 내 결석률이 $r_{max}$ 이상인 유저
  * 활성 유저는 이탈 유저가 아닌 유저

### 예측 데이터

군집별 예측 데이터 (*pred_data, P*) 를 다음과 같이 준비

* 예측 데이터 크기 (*pred_data_size, u_psize*) 는 예측에 필요한 유저별 데이터의 크기
  * 충분한 정보를 갖되 너무 오래된 데이터 사용을 지양하도록 설정
  * 유저별 참석 주기(f) 의 4 배로

$$U_{psize} = U_{freq} \times 4$$

* 예측 데이터 시작일 (*pred_data_begin, p_begin*) 은 예측 데이터의 시작 날자
* 예측 데이터 종료일 (*pred_data_end, p_end*) 은 예측 데이터 종료 날자
* 기준일 (*base_day, b*) 은 예측일부터 플레이 주기 (f) x 1.5 일 전
* 예측일 이전 $W_w$ 일 데이터에 대해
* 최소 참석일 이상 플레이한 유저들에 대해
* 예측 당일 데이터는 사용하지 않음



